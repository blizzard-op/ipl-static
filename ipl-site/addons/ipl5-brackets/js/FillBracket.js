// Generated by CoffeeScript 1.3.3
(function() {
  var Bracket, BracketRender, Group, GroupStage, GroupStageRender, Match, MiniMap, ProgressBar;

  window.FillBracket = (function() {

    function FillBracket($appContainer, gamePath) {
      var _this = this;
      this.$appContainer = $appContainer;
      this.defaultsc2Data = 'http://esports.ign.com/addons/ipl5-brackets/bin/sc2_seed.json';
      this.defaultlolData = 'http://esports.ign.com/addons/ipl5-brackets/bin/seed_bracket2.json';
      if(gamePath =="sc2"){
         this.viewId = this.defaultsc2Data;

      }else{
        this.viewId = this.defaultlolData;
        
      }

    
      this.cookieName = 'ipl-fantasy-bracket';
      this.getData(this.viewId, null, function(data) {
        return _this.bracketLoaded(data);
      });
    }


    FillBracket.prototype.checkForSessionCookie = function() {
      if ($.cookies.get(this.cookieName) != null) {
        console.log('Has cookie ' + $.cookies.get('ipl-fantasy-bracket'));
      } else {
        $.cookies.set(this.cookieName, this.makeSessionCookie());
        console.log('made a cookie: ' + $.cookies.get('ipl-fantasy-bracket'));
      }
      return $.cookies.get(this.cookieName);
    };

    FillBracket.prototype.makeSessionCookie = function() {
      var outCookie;
      outCookie = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
      outCookie = outCookie.replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
      return outCookie;
    };

    FillBracket.prototype.hookFrontend = function() {
      var _this = this;
      $('#auth-btn').click(function() {
        _this.showAuthModal();
        return false;
      });
      $('#clear-cookie-btn').click(function() {
        console.log('deleted cookie');
        return $.cookies.del(_this.cookieName);
      });
      return true;
    };

    FillBracket.prototype.checkLogin = function() {
      return $.ajax({
        'url': this.authApi,
        'dataType': 'jsonp',
        'jsonpCallback': 'jsonp',
        'processData': false,
        'cache': true,
        'success': function(data) {
          return console.log(data);
        }
      });
    };

    FillBracket.prototype.bracketLoaded = function(data) {
      var groupPainter, painter,
        _this = this;
      this.$paddingLayer = $('<div class="IPLPadding">').appendTo(this.$appContainer);
      this.$bracketLayer = $('<div class="IPLBracketLayer">').appendTo(this.$paddingLayer);
      this.$mapLayer = $('<div class="mini-map-layer">').appendTo(this.$appContainer.parent());
      this.$completionBar = $('<div class="progress-bar">').appendTo(this.$appContainer.parent()).hide();
      this.bracket = new Bracket(data);
      painter = new BracketRender(data, this.$bracketLayer);
      painter.renderBracket(this.bracket, this.$bracketLayer);
      if (data.groups != null) {
        this.$groupLayer = $('<div class="IPLGroupLayer">').appendTo(this.$paddingLayer);
        this.groupStage = new GroupStage(data.groups, this.bracket);
        groupPainter = new GroupStageRender(this.$groupLayer);
        groupPainter.render(this.groupStage);
        this.hookGroupStage();
      }
      this.hookDragNDrop();
      this.hookResize(painter);
      this.map = new MiniMap(this.$appContainer, this.bracket, this.$mapLayer, this.$appContainer, this.groupStage);
      this.progBar = new ProgressBar(this.$completionBar, this.bracket);
      if (this.progBar.complete) {
        this.progBar.fadeOut();
      } else {
        this.progBar.onComplete = function() {
          return true;
        };
      }
      return this.alignUI(painter);
    };

    FillBracket.prototype.getData = function(Url, Id, Callback) {
      var _this = this;
      return $.ajax({
        'url': Url + (Id != null ? Id : ""),
        'dataType': 'jsonp',
        'jsonpCallback': 'jsonp',
        'processData': false,
        'cache': true,
        'beforeSend': function(xhr, settings) {
          return settings.url = settings.url.split('?')[0];
        },
        'success': function(data) {
          return Callback(data);
        }
      });
    };

    FillBracket.prototype.showAuthModal = function() {
      var _this = this;
      return $.ajax({
        'url': 'http://widgets.ign.com/social/shared/registration/signin.jsonp?disable_js=false&r=http%3A%2F%2Fesports.ign.com%3A8080%2Ffantasy%2F',
        'url': '',
        'jsonpCallback': 'regModal',
        'dataType': 'jsonp',
        'success': function(data) {
          return $('body').append(data);
        }
      });
    };

    FillBracket.prototype.altAuthModal = function() {
      return $('#authModal').modal({
        'backdrop': true,
        'fade': true,
        'show': true
      });
    };

    FillBracket.prototype.saveBracket = function(Url, Callback, Data) {
      var _this = this;
      return $.ajax({
        'url': Url + Data,
        'type': 'POST',
        'contentType': 'application/json',
        'processData': false,
        'async': false,
        'data': JSON.stringify(this.bracket.toJSON()),
        'beforeSend': function(xhr, settings) {
          settings.url = settings.url.split('?')[0];
          settings.type = "PUT";
          settings.dataType = 'jsonp';
          return settings.jsonpCallback = 'jsonp';
        },
        'success': function(data) {
          return Callback(data);
        }
      });
    };

    FillBracket.prototype.hookAutoSave = function() {
      var _this = this;
      return $(window).on('beforeunload', function(data) {
        if (_this.bracket.sessionChanges > 0) {
          _this.saveBracket(_this.fantasyApi, function(data) {
            return true;
          }, _this.bracket.id);
        }
        return null;
      });
    };

    FillBracket.prototype.hookSaveBtn = function() {
      var _this = this;
      return $('a#save-btn').click(function() {
        if (_this.bracket.sessionChanges > 0) {
          _this.saveBracket(_this.fantasyApi, function(data) {
            return true;
          }, _this.bracket.id);
        }
        return false;
      });
    };

    FillBracket.prototype.hookGroupStage = function() {
      var a, g, _i, _len, _ref, _results,
        _this = this;
      $('.sortGroupList').sortable({
        'update': function(event, ui) {
          var $players, group, m, newPlayerOrder, _i, _len, _ref, _results;
          group = ui.item.parent('ul').data('group');
          $players = ui.item.parent('ul').find('li');
          newPlayerOrder = [];
          $players.each(function(index) {
            $(this).find('span').text(index + 1);
            return newPlayerOrder.push($($players[index]).data('player'));
          });
          group.players = newPlayerOrder;
          _ref = _this.groupStage.placeGroup(group);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            _results.push(_this.updateMatch(m));
          }
          return _results;
        },
        'placeholder': 'placeHolder'
      });
      _ref = this.groupStage.groups;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = this.groupStage.placeGroup(g);
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            a = _ref1[_j];
            _results1.push(this.updateMatch(a));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    FillBracket.prototype.hookDragNDrop = function() {
      var bracket,
        _this = this;
      bracket = this.bracket;
      $('.player').draggable({
        'revert': false,
        'helper': 'clone',
        'start': function(event, ui) {
          var m, pm, r, _i, _len, _ref, _results;
          ui.helper.css({
            'background-color': 'rgba(255,255,255,.6)',
            'border-radius': '8px',
            'cursor': 'move'
          });
          pm = $(event.currentTarget).parent('.match').data('match');
          _ref = bracket.rounds;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            r = _ref[_i];
            _results.push((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = r.length; _j < _len1; _j++) {
                m = r[_j];
                if (pm.hasParent(m)) {
                  _results1.push(m.$element.addClass('possible'));
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            })());
          }
          return _results;
        },
        'stop': function(event, ui) {
          return $('div.match.possible').removeClass('possible');
        }
      }).click(function(event) {
        var m, match, player, _i, _len, _ref;
        match = $(event.currentTarget).parent('.match').data('match');
        player = $(event.currentTarget).data('player');
        if (player != null) {
          _ref = bracket.advancePlayer(player, match);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            _this.updateMatch(m);
          }
        }
        _this.progBar.update();
        return _this.map.update();
      });
      return $('.match').droppable({
        accept: '.player',
        drop: function(event, ui) {
          var curPlayer, dragMatch, dropMatch, match, _i, _len, _ref;
          dragMatch = ui.draggable.parent('.match').data('match');
          dropMatch = $(event.target).data('match');
          curPlayer = ui.draggable.data('player');
          if (dragMatch.hasParent(dropMatch) && (curPlayer != null)) {
            _ref = bracket.advancePlayer(curPlayer, dragMatch, dropMatch);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              match = _ref[_i];
              _this.updateMatch(match);
            }
            _this.progBar.update();
            return _this.map.update();
          }
        }
      });
    };

    FillBracket.prototype.hookResize = function(painter) {
      var _this = this;
      $(window).resize(function(event) {
        _this.alignUI(painter);
        _this.map.drawView();
        return _this.map.reposition();
      });
      return $(this.$appContainer).scroll(function(event) {
        if (!_this.map.draggingView) {
          _this.map.drawView();
        }
        return _this.alignUI(painter);
      });
    };

    FillBracket.prototype.alignUI = function(painter) {
      painter.centerObject(this.$paddingLayer);
      this.centerElement(this.$completionBar, 'x');
      this.$completionBar.css({
        'top': $(window).height() - this.$completionBar.outerHeight() * 2 + this.$completionBar.parent().scrollTop()
      });
      this.map.reposition();
      if ($(window).height() < this.$paddingLayer.outerHeight() + 32) {
        return $('.navbar').css({
          'width': $(window).width() - 20
        });
      } else {
        return $('.navbar').css({
          'width': '100%'
        });
      }
    };

    FillBracket.prototype.updateMatch = function(match) {
      var filledSlots, nextSlot;
      filledSlots = 0;
      match.$element.find('.player').each(function(i) {
        if (match.players[i] != null) {
          $(this).find('.player-title').text(match.players[i].name);
          filledSlots += 1;
        }
        return $(this).data('player', match.players[i]);
      });
      match.$element.removeClass('active-match filled');
      if (!match.hasOpenSlot()) {
        match.$element.addClass('filled');
        if (match.parent != null) {
          nextSlot = match.parent.whichChild(match);
          nextSlot = match.parent.locked[nextSlot] ? (nextSlot < 1 ? 1 : 0) : nextSlot;
          if (match.parent.players[nextSlot] == null) {
            return match.$element.addClass('active-match');
          }
        }
      }
    };

    FillBracket.prototype.centerElement = function($target, axis) {
      if (axis == null) {
        axis = null;
      }
      if (axis === null || axis === 'x') {
        $target.css({
          'left': ($(window).outerWidth() / 2) - ($target.outerWidth() / 2) + $target.parent().scrollLeft()
        });
      }
      if (axis === null || axis === 'y') {
        return $target.css({
          'top': ($(window).outerHeight() / 2) - ($target.outerHeight() / 2) + $target.parent().scrollTop()
        });
      }
    };

    return FillBracket;

  })();

  GroupStage = (function() {

    function GroupStage(groupData, bracket) {
      var g, _i, _len;
      this.bracket = bracket;
      this.groups = [];
      for (_i = 0, _len = groupData.length; _i < _len; _i++) {
        g = groupData[_i];
        this.groups.push(new Group(g, this.bracket.playerLookup));
      }
    }

    GroupStage.prototype.placeGroup = function(group) {
      var a, a2, i, touched, _i, _len, _ref, _ref1;
      touched = [];
      _ref = group.advanceTo;
      for (i in _ref) {
        a2 = _ref[i];
        _ref1 = this.bracket.placePlayer(this.bracket.rounds[a2.x][a2.y], group.players[i], a2.slot);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          a = _ref1[_i];
          touched.push(a);
        }
      }
      return touched;
    };

    return GroupStage;

  })();

  Group = (function() {

    function Group(data, playerRef) {
      var a2, l, p, _i, _len, _ref, _ref1;
      if (playerRef == null) {
        playerRef = [];
      }
      this.name = data.name;
      this.players = [];
      this.advanceTo = [];
      this.$element = null;
      _ref = data.players;
      for (l in _ref) {
        p = _ref[l];
        if ((playerRef != null) && (playerRef[p.name] != null)) {
          this.players[l] = playerRef[p.name];
        } else {
          playerRef[p.name] = p;
          this.players[l] = p;
        }
      }
      _ref1 = data.advanceTo;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        a2 = _ref1[_i];
        this.advanceTo.push(a2);
      }
    }

    Group.prototype.updatePlacing = function() {
      return true;
    };

    return Group;

  })();

  Bracket = (function() {

    function Bracket(bracketData) {
      var a, b, i, j, k, l, match, p, pair, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      this.name = bracketData.name;
      this.kind = bracketData.kind;
      this.user_id = bracketData.userid;
      this.slug = bracketData.slug;
      this.session_id = bracketData.sessionid;
      this.id = bracketData.id;
      this.rounds = [];
      this.seedMatches = [];
      this.losersStart = bracketData.firstLoserRound;
      this.labels = [];
      this.roundTitles = [];
      this.completion = 0;
      this.totalSlots = 0;
      this.filledSlots = 0;
      this.sessionChanges = 0;
      this.playerLookup = {};
      this.winnerSpacing = bracketData.winnerSpacing;
      this.loserSpacing = bracketData.loserSpacing;
      _ref = bracketData.rounds;
      for (i in _ref) {
        a = _ref[i];
        this.rounds[i] = [];
        this.roundTitles[i] = a.name;
        _ref1 = a.matches;
        for (j in _ref1) {
          b = _ref1[j];
          match = this.rounds[i][j] = new Match(b.match, i);
          if (match.playerInLockedSlot()) {
            this.seedMatches.push(match);
          }
        }
      }
      _ref2 = bracketData.rounds;
      for (i in _ref2) {
        a = _ref2[i];
        _ref3 = a.matches;
        for (j in _ref3) {
          b = _ref3[j];
          if (b.match.loserDropsTo != null) {
            this.rounds[i][j].dropsTo = this.rounds[b.match.loserDropsTo[0]][b.match.loserDropsTo[1]];
          }
          if ((b.match.parent != null) && b.match.parent.length > 0) {
            this.rounds[i][j].parent = this.rounds[b.match.parent[0]][b.match.parent[1]];
          }
          if (b.match.children.length > 0) {
            this.rounds[i][j].children = [];
            _ref4 = b.match.children;
            for (k in _ref4) {
              pair = _ref4[k];
              this.rounds[i][j].children[k] = this.rounds[pair[0]][pair[1]];
            }
          }
          _ref5 = b.match.players;
          for (l in _ref5) {
            p = _ref5[l];
            if (p != null) {
              if (this.playerLookup[p.name] != null) {
                b.match.players[l] = this.playerLookup[p.name];
              } else {
                this.playerLookup[p.name] = b.match.players[l];
              }
            }
          }
        }
      }
    }

    Bracket.prototype.getCompletion = function() {
      var b, i, match, rnds, _i, _j, _len, _len1, _ref, _ref1;
      this.totalSlots = 0;
      this.filledSlots = 0;
      _ref = this.rounds;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rnds = _ref[_i];
        for (_j = 0, _len1 = rnds.length; _j < _len1; _j++) {
          match = rnds[_j];
          _ref1 = match.locked;
          for (i in _ref1) {
            b = _ref1[i];
            if (!b) {
              if (match.players[i] != null) {
                ++this.filledSlots;
              }
              ++this.totalSlots;
            }
          }
        }
      }
      return this.filledSlots / this.totalSlots;
    };

    Bracket.prototype.toJSON = function() {
      return JSON.stringify(this.toJSONObject());
    };

    Bracket.prototype.toJSONObject = function() {
      var a, i, jsOb, match, _i, _len, _ref;
      jsOb = {
        'kind': this.kind,
        'firstLoserRound': this.losersStart,
        'sessionid': this.session_id,
        'userid': this.user_id,
        'name': this.name,
        'slug': this.slug,
        'loserSpacing': this.loserSpacing,
        'winnerSpacing': this.winnerSpacing
      };
      jsOb.rounds = [];
      _ref = this.rounds;
      for (i in _ref) {
        a = _ref[i];
        jsOb.rounds[i] = {};
        jsOb.rounds[i].position = i;
        if (this.roundTitles[i] != null) {
          jsOb.rounds[i].name = this.roundTitles[i];
        }
        jsOb.rounds[i].matches = [];
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          match = a[_i];
          jsOb.rounds[i].matches.push({
            'match': match.toJSONObject()
          });
        }
      }
      return jsOb;
    };

    Bracket.prototype.placePlayer = function(match, player, slot, touched) {
      var a, b, c, needsChange, playerSlot, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      if (touched == null) {
        touched = [];
      }
      playerSlot = match.parent.whichChild(match);
      if (match.players[slot] != null) {
        playerSlot = match.parent.locked[playerSlot] ? (playerSlot < 1 ? 1 : 0) : playerSlot;
        needsChange = match.parent.replaceSlotForward(match.parent.whichChild(match), match.parent.players[playerSlot], player);
        for (_i = 0, _len = needsChange.length; _i < _len; _i++) {
          a = needsChange[_i];
          touched.push(a);
        }
      }
      match.players[slot] = player;
      touched.push(match);
      touched.push(match.parent);
      _ref = match.dropLoser(match);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        b = _ref[_j];
        touched.push(b);
      }
      _ref1 = match.parent.dropLoser(match);
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        c = _ref1[_k];
        touched.push(c);
      }
      return touched;
    };

    Bracket.prototype.advancePlayer = function(player, match, matchTo, touched) {
      var a, b, c, needsChange, playerSlot, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      if (touched == null) {
        touched = [];
      }
      if (!(match.parent != null)) {
        return touched;
      }
      this.sessionChanges += 1;
      playerSlot = match.parent.whichChild(match);
      playerSlot = match.parent.locked[playerSlot] ? (playerSlot < 1 ? 1 : 0) : playerSlot;
      if (match.parent.players[playerSlot] != null) {
        needsChange = match.parent.replaceSlotForward(match.parent.whichChild(match), match.parent.players[playerSlot], player);
        for (_i = 0, _len = needsChange.length; _i < _len; _i++) {
          a = needsChange[_i];
          touched.push(a);
        }
      }
      match.parent.players[playerSlot] = player;
      touched.push(match.parent);
      touched.push(match);
      _ref = match.dropLoser(match);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        b = _ref[_j];
        touched.push(b);
      }
      _ref1 = match.parent.dropLoser(match);
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        c = _ref1[_k];
        touched.push(c);
      }
      if ((matchTo != null) && match.parent !== matchTo) {
        return this.advancePlayer(player, match.parent, matchTo, touched);
      }
      return touched;
    };

    Bracket.prototype.whichBranch = function(match) {
      if (match.loc.y < parseInt(this.rounds[match.loc.x].length / 2)) {
        return 0;
      } else {
        return 1;
      }
    };

    return Bracket;

  })();

  Match = (function() {

    function Match(matchData, round) {
      this.players = matchData.players;
      this.parent = null;
      this.children = [];
      this.connectors = [];
      this.dropsTo = null;
      this.$element = null;
      this.locked = matchData.locked;
      this.loc = {
        "x": parseInt(round),
        "y": parseInt(matchData.position)
      };
      this.transform = matchData.transform ? matchData.transform : null;
    }

    Match.prototype.validate = function() {};

    Match.prototype.toJSONObject = function(sparce) {
      var a, i, jsOut, _ref;
      if (sparce == null) {
        sparce = false;
      }
      jsOut = {};
      jsOut.players = this.players;
      jsOut.position = this.loc.y;
      if (!sparce) {
        jsOut.locked = this.locked;
        jsOut.parent = null;
        jsOut.children = null;
        if (this.parent != null) {
          jsOut.parent = [this.parent.loc.x, this.parent.loc.y];
        }
        if (this.children != null) {
          jsOut.children = [];
          _ref = this.children;
          for (i in _ref) {
            a = _ref[i];
            jsOut.children[i] = [a.loc.x, a.loc.y];
          }
        }
        jsOut.loserDropsTo = null;
        if (this.dropsTo != null) {
          jsOut.loserDropsTo = [this.dropsTo.loc.x, this.dropsTo.loc.y];
        }
        if (this.transform != null) {
          jsOut.transform = {
            'x': this.transform.x,
            'y': this.transform.y
          };
        }
      }
      return jsOut;
    };

    Match.prototype.hasOpenSlot = function() {
      var i, p, _ref;
      _ref = this.players;
      for (i in _ref) {
        p = _ref[i];
        if (!(p != null)) {
          if (!this.locked[i]) {
            return true;
          }
        }
      }
      return false;
    };

    Match.prototype.playerInLockedSlot = function() {
      var i, l, _ref;
      _ref = this.locked;
      for (i in _ref) {
        l = _ref[i];
        if (l && (this.players[i] != null)) {
          return true;
        }
      }
      return false;
    };

    Match.prototype.whichChild = function(match) {
      var i, m, _ref;
      _ref = this.children;
      for (i in _ref) {
        m = _ref[i];
        if (m === match) {
          return i;
        }
      }
      return null;
    };

    Match.prototype.whichSlot = function(match) {
      var i, m, _ref;
      _ref = this.children;
      for (i in _ref) {
        m = _ref[i];
        if (m === match) {
          if (!this.locked[i]) {
            return i;
          } else {
            if (i < 1) {
              return 1;
            } else {
              return 0;
            }
          }
        }
      }
      return null;
    };

    Match.prototype.playerFromChild = function(player) {
      var c, i, p, _i, _len, _ref, _ref1;
      _ref = this.children;
      for (i in _ref) {
        c = _ref[i];
        _ref1 = c.players;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          p = _ref1[_i];
          if (p === player) {
            return i;
          }
        }
      }
      return null;
    };

    Match.prototype.hasPlayer = function(player) {
      var p, _i, _len, _ref;
      if (player == null) {
        return false;
      }
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p === player) {
          return true;
        }
      }
      return false;
    };

    Match.prototype.countPlayers = function() {
      var cur, p, _i, _len, _ref;
      cur = 0;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p != null) {
          cur += 1;
        }
      }
      return cur;
    };

    Match.prototype.hasParent = function(match) {
      if (!(this.parent != null)) {
        return false;
      } else if (this.parent === match) {
        return true;
      } else {
        return this.parent.hasParent(match);
      }
    };

    Match.prototype.isChild = function(player) {
      var c, i, _ref;
      _ref = this.players;
      for (i in _ref) {
        c = _ref[i];
        if (c === player) {
          return i;
        }
      }
      return null;
    };

    Match.prototype.hasWinner = function() {
      var i, p, pl, slot, _ref;
      if (this.parent == null) {
        return null;
      }
      slot = this.parent.whichChild(this);
      p = this.parent.players[slot];
      _ref = this.players;
      for (i in _ref) {
        pl = _ref[i];
        if (pl != null) {
          if (p === pl) {
            return i;
          }
        }
      }
      return null;
    };

    Match.prototype.dropLoser = function(matchFrom) {
      var a, lockedSlot, loser, touched, winner, _i, _len, _ref;
      winner = this.hasWinner();
      touched = [];
      if ((this.dropsTo != null) && (winner != null)) {
        touched.push(this.dropsTo);
        loser = this.players[winner < 1 ? 1 : 0];
        lockedSlot = this.dropsTo.locked[0] ? 0 : 1;
        if (this.dropsTo.locked[0] && this.dropsTo.locked[1]) {
          lockedSlot = this.loc.y % 2 === 0 ? 0 : 1;
        }
        if ((this.dropsTo.players[lockedSlot] != null) && (loser != null)) {
          _ref = this.dropsTo.replaceSlotForward(this.parent.whichChild(this), this.dropsTo.players[lockedSlot], loser);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            a = _ref[_i];
            touched.push(a);
          }
        }
        this.dropsTo.players[lockedSlot] = loser;
      }
      return touched;
    };

    Match.prototype.replaceSlotForward = function(slot, replace, replaceWith, touched) {
      var b, ns, _i, _len, _ref;
      if (touched == null) {
        touched = [];
      }
      slot = this.locked[slot] ? (slot < 1 ? 1 : 0) : slot;
      if ((this.players[slot] != null) && this.players[slot] === replace) {
        this.players[slot] = replaceWith;
        touched.push(this);
      }
      if (this.parent != null) {
        ns = this.parent.whichSlot(this);
        if ((this.parent.players[ns] != null) && this.parent.players[ns] === replace) {
          return this.parent.replaceSlotForward(this.parent.whichSlot(this), replace, replaceWith, touched);
        }
      }
      _ref = this.dropLoser(this);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        touched.push(b);
      }
      return touched;
    };

    return Match;

  })();

  GroupStageRender = (function() {

    function GroupStageRender($groupLayer) {
      this.$groupLayer = $groupLayer;
      true;
    }

    GroupStageRender.prototype.render = function(group) {
      var $el, $title, g, i, _ref;
      this.group = group;
      this.$groupLayer.hide();
      _ref = this.group.groups;
      for (i in _ref) {
        g = _ref[i];
        $el = this.renderGroup(g).css({
          'top': i * 180 + 35,
          'left': 0
        });
        $title = $('<div class="round-title">').appendTo(this.$groupLayer).text(g.name);
        $title.css({
          'left': parseInt($el.css('left')) + 10,
          'top': parseInt($el.css('top')) - 14
        });
      }
      $el = this.group.groups[this.group.groups.length - 1].$element;
      this.$groupLayer.css({
        'height': parseInt($el.css('top')) + parseInt($el.outerHeight()) + 40
      });
      return this.$groupLayer.fadeIn('slow');
    };

    GroupStageRender.prototype.renderGroup = function(group) {
      var $el, $pList, $pl, p, _i, _len, _ref;
      $el = group.$element = $('<div class="group">').appendTo(this.$groupLayer);
      $pList = $('<ul class="sortGroupList">').appendTo($el).disableSelection().data('group', group);
      _ref = group.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        $pl = $('<li>').appendTo($pList).data('player', p);
        $pl.text(p.name);
        $('<span class="seedPlace">').prependTo($pl).text($pl.index() + 1);
      }
      return $el;
    };

    return GroupStageRender;

  })();

  BracketRender = (function() {

    function BracketRender($bracketLayer, bracket, matchClass) {
      this.$bracketLayer = $bracketLayer;
      this.matchClass = matchClass != null ? matchClass : 'match';
    }

    BracketRender.prototype.renderBracket = function(bracket, $layer) {
      var $match, $round, a, b, i, j, m, match, maxHeight, maxWidth, nx, ny, r, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3;
      this.$bracketLayer = $layer;
      this.losersStart = bracket.losersStart;
      maxWidth = 0;
      maxHeight = 0;
      this.loserSpacing = bracket.loserSpacing != null ? bracket.loserSpacing : 140;
      this.winnerSpacing = bracket.winnerSpacing != null ? bracket.winnerSpacing : 270;
      $layer.hide();
      _ref = bracket.rounds;
      for (i in _ref) {
        a = _ref[i];
        $round = $('<div class="round">').appendTo($layer);
        for (j in a) {
          b = a[j];
          if (!b.transform) {
            b.transform = null;
          }
          $match = this.renderMatch(b, $round, b.transform);
          if (!b.hasOpenSlot() && (b.parent != null) && !(b.parent.players[b.parent.whichSlot(b)] != null) && b.countPlayers() > 0) {
            $match.addClass('active-match');
          } else if (!b.hasOpenSlot() && b.countPlayers() > 0) {
            $match.addClass('filled');
          }
          $match.data('loc', {
            'x': i,
            'y': j
          });
        }
      }
      for (i = _i = _ref1 = bracket.losersStart - 3, _ref2 = bracket.losersStart - 1; _ref1 <= _ref2 ? _i < _ref2 : _i > _ref2; i = _ref1 <= _ref2 ? ++_i : --_i) {
        match = bracket.rounds[i][0];
        nx = 220 + parseInt(match.children[0].$element.css('left'));
        ny = match.children.length === 2 ? (parseInt(match.children[0].$element.css('top')) + parseInt(match.children[1].$element.css('top'))) * 0.5 : parseInt(match.children[0].$element.css('top'));
        match.$element.css({
          'top': ny,
          'left': nx
        });
      }
      _ref3 = bracket.rounds;
      for (_j = 0, _len = _ref3.length; _j < _len; _j++) {
        r = _ref3[_j];
        for (_k = 0, _len1 = r.length; _k < _len1; _k++) {
          m = r[_k];
          $match = m.$element;
          maxWidth = Math.max($match.outerWidth() + parseInt($match.css('left')), maxWidth);
          maxHeight = Math.max($match.outerHeight() + parseInt($match.css('top')), maxHeight);
        }
      }
      $layer.css({
        'height': maxHeight,
        'width': maxWidth
      });
      $layer.parent().css({
        'height': maxHeight,
        'width': maxWidth
      });
      this.connectMatches(bracket.rounds[this.losersStart - 2][0]);
      this.addRoundTitles(bracket);
      this.formatGrandChampion(bracket.rounds[this.losersStart - 2][0].$element);
      $layer.fadeIn('slow');
      return $layer;
    };

    BracketRender.prototype.renderMatch = function(match, $layer, transform) {
      var $match, $player, $pt, maxHeight, maxWidth, player, roundSpacing, _i, _len, _ref;
      if (transform == null) {
        transform = null;
      }
      maxWidth = 0;
      maxHeight = 0;
      $match = $('<div class="' + this.matchClass + '">').appendTo($layer);
      $player = null;
      roundSpacing = match.loc.x < this.losersStart ? this.winnerSpacing : this.loserSpacing;
      _ref = match.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        $player = $('<div class="player">').appendTo($match);
        $pt = $('<span class="player-title">').appendTo($player);
        if ((player != null) && (player.id != null)) {
          $player.find('.player-title').text(player.name);
          $player.data('player', player);
        } else {
          $player.data('player', null);
          $player.find('.player-title').text('x');
        }
      }
      if ((match.players[0] != null) && (match.players[1] != null)) {
        $match.addClass('filled');
      }
      if (transform != null) {
        if (transform.x != null) {
          $match.css({
            'left': transform.x
          });
          if (transform.y != null) {
            $match.css({
              'top': transform.y
            });
          }
        }
      } else if (match.children.length === 2) {
        if ((match.children[0].$element != null) && (match.children[1].$element != null)) {
          $match.css({
            'left': roundSpacing + parseInt(match.children[0].$element.css('left')),
            'top': (parseInt(match.children[0].$element.css('top')) + parseInt(match.children[1].$element.css('top'))) * 0.5
          });
        }
      } else if (match.children.length === 1) {
        $match.css({
          'left': roundSpacing + parseInt(match.children[0].$element.css('left')),
          'top': parseInt(match.children[0].$element.css('top'))
        });
      }
      $match.data('match', match);
      match.$element = $match;
      return $match;
    };

    BracketRender.prototype.formatGrandChampion = function($match) {
      $match.find('.player').first().hide();
      return $match.find('.player').last().css({
        height: '100%',
        border: 'none'
      });
    };

    BracketRender.prototype.addRoundTitles = function(bracket) {
      var $title, i, title, _ref, _results;
      _ref = bracket.roundTitles;
      _results = [];
      for (i in _ref) {
        title = _ref[i];
        $title = $('<div class="round-title">').appendTo(this.$bracketLayer).text(title);
        _results.push($title.css({
          'left': bracket.rounds[i][0].$element.css('left'),
          'top': parseInt(bracket.rounds[i][0].$element.css('top')) - 20
        }));
      }
      return _results;
    };

    BracketRender.prototype.centerObject = function($target, axis) {
      if (axis == null) {
        axis = null;
      }
      if (axis === null || axis === 'x') {
        if ($target.outerWidth() < $(window).width()) {
          $target.css({
            'left': ($(window).outerWidth() / 2) - ($target.outerWidth() / 2)
          });
        }
      }
      if (axis === null || axis === 'y') {
        if ($target.outerHeight() < $(window).height()) {
          return $target.css({
            'top': ($(window).outerHeight() / 2) - ($target.outerHeight() / 2)
          });
        }
      }
    };

    BracketRender.prototype.connectMatches = function(match) {
      var $c, a, i, _ref, _results;
      if (match.children.length > 0) {
        _ref = match.children;
        _results = [];
        for (i in _ref) {
          a = _ref[i];
          if (match.children.length > 1) {
            $c = $('<div class="match-connector-top">').appendTo(this.$bracketLayer);
            match.connectors[0] = $c;
            $c.css({
              'width': (parseInt(match.$element.css('left')) - (parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + 2)) * .5,
              'height': (parseInt(match.children[1].$element.css('top')) - parseInt(match.children[0].$element.css('top'))) * .5 - 2,
              'top': parseInt(match.children[0].$element.css('top')) + parseInt(match.children[0].$element.css('height')) * .5 + 1,
              'left': parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + 1
            });
            $c = $('<div class="match-connector-bottom">').appendTo(this.$bracketLayer);
            match.connectors[1] = $c;
            $c.css({
              'width': (parseInt(match.$element.css('left')) - (parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + 2)) * .5,
              'height': (parseInt(match.children[1].$element.css('top')) - parseInt(match.children[0].$element.css('top'))) * .5,
              'top': parseInt(match.$element.css('top')) + parseInt(match.$element.css('height')) * .5 + 1,
              'left': parseInt(match.children[1].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + 1
            });
            $c = $('<div class="match-connector-center">').appendTo(this.$bracketLayer);
            $c.css({
              'width': (parseInt(match.$element.css('left')) - (parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + 2)) * .5,
              'top': parseInt(match.$element.css('top')) + parseInt(match.$element.css('height')) * .5 + 1,
              'left': parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + (parseInt(match.$element.css('left')) - (parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')))) * .5 + 1
            });
          } else {
            $c = $('<div class="match-connector-center">').appendTo(this.$bracketLayer);
            $c.css({
              'width': parseInt(match.$element.css('left')) - (parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + 2),
              'top': parseInt(match.$element.css('top')) + parseInt(match.$element.css('height')) * .5 + 1,
              'left': parseInt(match.children[0].$element.css('left')) + parseInt(match.children[0].$element.css('width')) + 2
            });
          }
          _results.push(this.connectMatches(a));
        }
        return _results;
      } else {
        return null;
      }
    };

    return BracketRender;

  })();

  ProgressBar = (function() {

    function ProgressBar($bar, bracket) {
      this.$bar = $bar;
      this.bracket = bracket;
      this.bracket.getCompletion();
      this.complete = false;
      this.barSlots = 0;
      this.onComplete = null;
      this.stepSize = 1 / this.bracket.totalSlots;
      this.$bsBar = $('<div class="progress">').appendTo(this.$bar);
      this.text = $('<div class="progress-text">').appendTo(this.$bar);
      this.update();
      if (this.bracket.filledSlots < 1) {
        this.text.text('Click or drag a team to begin...');
      }
    }

    ProgressBar.prototype.update = function() {
      var i, per, _i, _ref;
      per = this.bracket.getCompletion() * 100;
      this.text.text((per.toFixed(0)) + '%');
      for (i = _i = 0, _ref = this.bracket.filledSlots - this.barSlots; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        $('<div class="bar bar-danger">').appendTo(this.$bsBar).width((this.stepSize * 100) + '%');
        ++this.barSlots;
      }
      if (per === 100 && !this.complete) {
        this.complete = true;
        if (this.onComplete != null) {
          return this.onComplete();
        }
      }
    };

    ProgressBar.prototype.fadeOut = function() {
      return this.$bar.fadeOut('slow');
    };

    return ProgressBar;

  })();

  MiniMap = (function() {

    function MiniMap($bracketLayer, bracket, $mapLayer, $appContainer, groups) {
      var that,
        _this = this;
      this.$bracketLayer = $bracketLayer;
      this.bracket = bracket;
      this.$mapLayer = $mapLayer;
      this.$appContainer = $appContainer;
      this.groups = groups != null ? groups : null;
      this.maxWidth = 120;
      this.scale = this.maxWidth / this.$appContainer.find('.IPLPadding').outerWidth();
      this.mapHeight = parseInt(this.$appContainer.find('.IPLPadding').outerHeight() * this.scale);
      this.mapWidth = parseInt(this.$appContainer.find('.IPLPadding').outerWidth() * this.scale);
      this.$canvasOb = $('<canvas id="mini-map" height=' + this.mapHeight + ' width=' + this.mapWidth + '>').css('z-index', 2).appendTo(this.$mapLayer);
      this.canvas = this.$canvasOb[0].getContext("2d");
      this.draggingView = false;
      this.$mapLayer.css({
        'position': 'absolute',
        'width': this.mapWidth,
        'height': this.mapHeight,
        'overflow': 'hidden'
      });
      this.$viewRect = $('<div class="viewRect">').appendTo(this.$mapLayer);
      that = this;
      this.$viewRect.draggable({
        'containment': 'parent',
        'start': function(event, ui) {
          return _this.draggingView = true;
        },
        'drag': function(event, ui) {
          var topX, topY;
          topX = _this.$viewRect.offset().left - _this.$mapLayer.offset().left;
          topY = _this.$viewRect.offset().top - _this.$mapLayer.offset().top;
          _this.$appContainer.scrollLeft(topX * (1 / _this.scale));
          return _this.$appContainer.scrollTop(topY * (1 / _this.scale));
        },
        stop: function() {
          _this.draggingView = false;
          return $(_this).removeClass('.ui-draggable-dragging');
        }
      });
      this.renderBracket();
      this.drawView();
    }

    MiniMap.prototype.renderBracket = function() {
      this.$mapLayer.css({
        'top': $(window).height() - this.$mapLayer.outerHeight() - 10,
        'left': $(window).width() - this.$mapLayer.outerWidth() - 10,
        'position': 'absolute'
      });
      return this.update();
    };

    MiniMap.prototype.update = function() {
      var g, m, padding, r, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      this.canvas.fillStyle = "#FFFFFF";
      this.canvas.clearRect(0, 0, this.mapWidth, this.mapHeight);
      padding = parseInt(this.$appContainer.find('.IPLPadding').css('padding-top'));
      _ref = this.bracket.rounds;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        for (_j = 0, _len1 = r.length; _j < _len1; _j++) {
          m = r[_j];
          if (m.$element.hasClass('active-match')) {
            this.canvas.fillStyle = "#FFFFFF";
          } else if (m.$element.hasClass('filled')) {
            this.canvas.fillStyle = "#888888";
          } else {
            this.canvas.fillStyle = "#FF6666";
          }
          this.canvas.fillRect((parseInt(m.$element.css('left')) + padding) * this.scale, (parseInt(m.$element.css('top')) + padding) * this.scale, m.$element.outerWidth() * this.scale, m.$element.outerHeight() * this.scale);
        }
      }
      this.canvas.fillStyle = "#888888";
      if (this.groups != null) {
        _ref1 = this.groups.groups;
        _results = [];
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          g = _ref1[_k];
          _results.push(this.canvas.fillRect((parseInt(g.$element.css('left')) + padding) * this.scale, (parseInt(g.$element.css('top')) + padding) * this.scale, g.$element.outerWidth() * this.scale, g.$element.outerHeight() * this.scale));
        }
        return _results;
      }
    };

    MiniMap.prototype.drawView = function() {
      var screenHeight, screenWidth;
      screenWidth = $(window).width();
      screenHeight = $(window).height();
      return this.$viewRect.css({
        'left': this.$appContainer.scrollLeft() * this.scale,
        'top': this.$appContainer.scrollTop() * this.scale,
        'width': screenWidth * this.scale,
        'height': screenHeight * this.scale
      });
    };

    MiniMap.prototype.reposition = function() {
      var screenHeight, screenWidth;
      screenWidth = $(window).width();
      screenHeight = $(window).height();
      this.$mapLayer.css({
        'top': $(window).height() - this.$mapLayer.outerHeight() - 50,
        'left': $(window).width() - this.$mapLayer.outerWidth() - 20
      });
      if (screenWidth > parseInt(this.$bracketLayer.css('width')) && screenHeight - 140 > parseInt(this.$bracketLayer.css('height'))) {
        return this.$mapLayer.hide();
      } else {
        return this.$mapLayer.show();
      }
    };

    return MiniMap;

  })();

}).call(this);
